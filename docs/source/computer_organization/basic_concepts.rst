数据(DATA)
==========
上一个小节，我们一直在和电路打交道，这一小节是一个独立的小节，我们将探讨计算机中的数据


关于进制
---------
在一开始，我们讲过，计算机是用来计算的，那这里就不能忽视掉 "计算的内容"，这就是计算机处理的数据，我们已经指导计算机使用的是二进制，相信通过前一章学习，你也明白为什么是二进制 而不是其他进制，因为计算机计算单元都是逻辑门组成的，他只能接收 0 和 1 ，因此计算机使用了二进制


关于数据含义
--------------
计算机不知道数据的含义，只负责数据计算，数据的含义由使用的人作为解释者解释；
这句话我需要讲一下 ： 计算机只提供计算能力： 这里隐含有  程序 和 数据 都不归计算机管, 比如一个二进制： 000011110001111 他是什么含义，由使用这个数据的程序解释，另外就算是程序本身，也是写程序的人决定的，计算机只负责加载程序 并执行，他不对数据解释

计算机是如何表达图片的？
 放大任何一张照片，你会看到图片就是一个一个小格子组成的，这些小格子实际上就是我们常说的像素格子，一个相机，像素越高，意味着一张照片拥有的像素格子越多，照片越细腻，每个像素格子其实就代表一个颜色，颜色是通过 RGB 来表示: Red Green Blue，red gree blue 每种颜色又被分为 256个等级,也就是颜色通过三原色被分为了 256*256*256种颜色，https://www.rapidtables.com/web/color/RGB_Color.html 你可以通过这个网址自己进行调色；

一张照片，由很多个像素格子组成，而每个像素格子代表一种颜色，不同的颜色连续组合在一起，就变成了照片，而每个像素格子，又可以通过 3个数字表示，也就是照片可以通过 无数个 3个数字表示 

计算机参与的一切工作本质上都是数据的处理

 - 电子温度计：电子温度计通过温度对电压的影响，把不同电压分为了不同的挡位，每个挡位对应不同的温度


基础常识
--------

byte&word
^^^^^^^^^^
由于1个bit 只能表示两种状态，我们需要以某种方式组装更多bit 表示更多含义，习惯于使用byte和word
老生常谈，多个bit组合 可以代表任何事情，取决你怎么解释他

 - 1byte = 8 bit 
 - 1byte 有256个状态
 - 1word = ? bit，取决于架构的定义 1word = 指针的大小 也就是可以寻址的范围
 - 32位可寻址内存范围4GB，内存寻址我们假设认为是按照字节寻址，也就是一个地址可以存储8bit,
    4294967296 * 8bit = 4294967296 byte = 4GB 关于内存工作原理 参考内存章节


二进制&转换&数据类型大小
^^^^^^^^^^^^^^^^^^^^^^^^
不在这里讲了 过于基础


内存编址
^^^^^^^^^
我们可以认为内存是字节寻址的，也就是我们编程说的 地址+1 的含义是什么，为什么内存地址+1代表移动了1byte(8bit) 就是建立在内存地址是按照byte编址的；简单粗暴点：
可以认为内存就是一个非常大的数组，数组元素大小是1BYTE， 这个数组的 index 就是内存地址


数据类型的存储
^^^^^^^^^^^^^^^
int short long 这些变量是怎么存储的？ 

变量访问: 变量的含义就是 一段地址的起始位置的别名，比如 int a,他占用四个字节，起始位置从 -0x1000开始，如果访问a，我们给CPU的地址就是 0x1000，内存大小4字节


大小端
^^^^^^^
大小端让类型存储变得稍微复杂了一点，回顾上个小节，我们已经知道: 

 - 一个int 占 4 个byte 内存
 - 变量*int a*表示的是 占用4个内存的首地址 

OK，现在我们有变量int a = 0x12345678 也有了四个byte 内存地址，我们可能会想当然的认为这四个内存
里面是按照顺序存放的 地址: 0x100: 0x12  0x101: 0x23 0x102: 0x56 0x103: 0x78 

非常不幸的并不一定是，其实我们在想一下，内存是怎么存放的对于使用变量的人重要吗？
当我们定义一个变量 *int a* 我们只是说 我有一个 数字，需要存储到这四个内存字节，而且当我使用这个变量计算
的时候，CPU自己需要能够清楚 他表示的数字，并且计算正确就行了。
换句话说，CPU自己决定数字放在这4个内存的顺序，并且读取的时候，按照存放顺序取出来就行

所以回到主题，计算机对于变量的实际内存排序有两种方式，大端和小端 

 - 大端：习惯上就是我们认为的，变量按照内存地址顺序，从低地址到高地址，顺序存放
 - 小端：和大端相反，变量按照内存地址顺序，从高地址到低地址，顺序存放

至于char * 和 结构体这种复合类型，参考http://uprprc.net/2017/10/10/little-endian.html 

bitwise基本计算
^^^^^^^^^^^^^^^^^^
逻辑运算
|  & ^ ~ 分别对应 或、与、XOR 以及 取反  

位移计算： 
  - 左移： 抛弃掉左边的bit，右边的bit 使用0填充
  - 逻辑右移  抛弃掉右边的bit，左边的bit 使用0填充
  - 算数右移：抛弃掉右边的bit，左边的bit 使用符号位填充

符号位
^^^^^^^
就算不是在计算机中，我们表示符号，也需要一个特殊的 “+-” 号，计算机只有bit，因此为了表示符号，使用最高有效位表示符号

比如： 1011 如果是无符号 他就是 11  有符号就是 -3 

但是符号数这里有个问题 1+ -1 = 0   0001 + 1001 = 1010  != 0  
为了满足这个特性，让我们看一下补码： 
6  =  0101 ；-6 =  1010(6取反)  6+-6 = 1111；不等于0，只需要在给补码加1即可 

所以，了解为什么需要补码 要比死记硬背 要更有意思 

1 = 0001  6 = 0110 -6 = 1010  1+-6 = 1011  5 = 0101 -5 = 1011

补码的另外一个特征就是：无论是从正数到复数，还是复数到正数，公式是一样的 取反+1


bitwise高阶计算
^^^^^^^^^^^^^^^

 - 设置某个bit为1 ： OR 掩码： 掩码为1,设置为1  掩码为0， bit 不变
 - 设置某个bit为0 ：AND 掩码： 掩码为0,设置为0, 掩码为1， bit不变
 - 反转某个bit ：   XOR 掩码： 掩码为1,反转，   掩码为0， bit不变




